{"ast":null,"code":"import{useState,useEffect,useMemo,useCallback}from'react';import{v4 as uuidv4}from'uuid';import{format,startOfMonth,endOfMonth,eachDayOfInterval,isAfter,isBefore,isSameDay,isWeekend,getDate}from'date-fns';import{useAuth}from'../context/AuthContext';const ENTRIES_STORAGE_KEY='personal-budget-tracker-entries';const RECURRING_PAYMENTS_STORAGE_KEY='personal-budget-tracker-recurring-payments';// Helper function to safely handle date serialization\nconst dateReviver=(key,value)=>{if(key==='date'||key==='startDate'||key==='endDate'){return new Date(value);}return value;};export const useFinancialData=function(){let currentDate=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Date();const{currentUser}=useAuth();const[entries,setEntries]=useState([]);const[recurringPayments,setRecurringPayments]=useState([]);// Get storage key for the current user\nconst getStorageKey=useCallback(key=>{return currentUser?`${key}-${currentUser.id}`:key;},[currentUser]);// Load entries from localStorage\nuseEffect(()=>{const savedEntries=localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));if(savedEntries){const parsedEntries=JSON.parse(savedEntries,dateReviver);setEntries(parsedEntries.map(entry=>({...entry,date:new Date(entry.date)})));}},[getStorageKey]);// Save entries to localStorage\nuseEffect(()=>{if(entries.length>0){localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY),JSON.stringify(entries));}else{// If there are no entries, remove the item from localStorage\nlocalStorage.removeItem(getStorageKey(ENTRIES_STORAGE_KEY));}},[entries,getStorageKey]);// Load recurring payments from localStorage\nuseEffect(()=>{const savedRecurringPayments=localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));if(savedRecurringPayments){const parsedPayments=JSON.parse(savedRecurringPayments,dateReviver);setRecurringPayments(parsedPayments.map(payment=>({...payment,startDate:new Date(payment.startDate),endDate:payment.endDate?new Date(payment.endDate):undefined,validFrom:new Date(payment.validFrom),validUntil:payment.validUntil?new Date(payment.validUntil):undefined})));}},[getStorageKey]);// Save recurring payments to localStorage\nuseEffect(()=>{if(recurringPayments.length>0){localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY),JSON.stringify(recurringPayments));}else{// If there are no recurring payments, remove the item from localStorage\nlocalStorage.removeItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));}},[recurringPayments,getStorageKey]);// Process recurring payments and generate entries\nuseEffect(()=>{const processRecurringPayments=()=>{// Current actual date (today)\nconst today=new Date();today.setHours(0,0,0,0);// Selected month in the UI (might be different from current month)\nconst selectedMonthStart=startOfMonth(currentDate);const selectedMonthEnd=endOfMonth(currentDate);// Consider a period of up to 30 days in the past from today (for historical data)\nconst pastProcessingDate=new Date(today);pastProcessingDate.setDate(pastProcessingDate.getDate()-30);// The start of processing should be the earlier of:\n// 1. 30 days before today (for recent past entries)\n// 2. The start of the selected month (for viewing past/future months)\nconst startDate=new Date(Math.min(pastProcessingDate.getTime(),selectedMonthStart.getTime()));// The end of processing should be the later of:\n// 1. The end of the current actual month (for immediate visibility)\n// 2. The end of the selected month (for viewing past/future months)\nconst endDate=new Date(Math.max(endOfMonth(today).getTime(),selectedMonthEnd.getTime()));// Prepare new entries generated from recurring payments\nconst newEntries=[];// Loop through all recurring payments\nrecurringPayments.forEach(payment=>{if(!payment.isActive)return;// Check if the payment is valid during any part of our processing window\nconst paymentEndDate=payment.validUntil||new Date(9999,11,31);// If no end date, use far future\n// If the payment's validity period doesn't overlap with our processing period, skip it\nif(isAfter(payment.validFrom,endDate)||isBefore(paymentEndDate,startDate)){return;}// Get dates to process based on schedule type\nlet datesToProcess=[];// Define start date for processing (max of payment's start date or our processing window start)\nconst processingStart=new Date(Math.max(payment.startDate.getTime(),startDate.getTime()));// Define end date for processing (min of payment's end date or processing window end)\nconst processingEnd=payment.endDate&&isBefore(payment.endDate,endDate)?payment.endDate:endDate;// Don't process if the processing period is invalid\nif(isAfter(processingStart,processingEnd))return;// Get candidate dates based on schedule type\nswitch(payment.scheduleType){case'specific-date':// For monthly payments on a specific day of month\nif(payment.frequency==='monthly'&&payment.dayOfMonth){// Get all days in the processing range\nconst allDays=eachDayOfInterval({start:processingStart,end:processingEnd});// Filter for days that match the day of month\ndatesToProcess=allDays.filter(date=>getDate(date)===payment.dayOfMonth);}// For yearly payments on a specific day of a specific month\nelse if(payment.frequency==='yearly'&&payment.dayOfMonth){// Get all days in the processing range\nconst allDays=eachDayOfInterval({start:processingStart,end:processingEnd});// Filter for days that match both the month and day\ndatesToProcess=allDays.filter(date=>getDate(date)===payment.dayOfMonth&&date.getMonth()===payment.startDate.getMonth());}break;case'weekdays-only':// Get all weekdays within the processing window\ndatesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd}).filter(date=>!isWeekend(date));break;case'weekends-only':// Get all weekend days within the processing window\ndatesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd}).filter(date=>isWeekend(date));break;case'custom-range':// Get all dates within the custom range\ndatesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd});// Apply frequency filtering\nswitch(payment.frequency){case'daily':// All days are included, so no additional filtering\nbreak;case'weekly':// Keep only days whose day of week matches the original start date\ndatesToProcess=datesToProcess.filter(date=>date.getDay()===payment.startDate.getDay());break;case'monthly':// Keep only days whose day of month matches the original start date\ndatesToProcess=datesToProcess.filter(date=>getDate(date)===getDate(payment.startDate));break;case'yearly':// Keep only days whose day and month match the original start date\ndatesToProcess=datesToProcess.filter(date=>getDate(date)===getDate(payment.startDate)&&date.getMonth()===payment.startDate.getMonth());break;}break;}// Create entries for each date to process\ndatesToProcess.forEach(date=>{// Check if an entry for this recurring payment already exists on this date\nconst entryExists=entries.some(entry=>isSameDay(entry.date,date)&&entry.description===`[Recurring] ${payment.description}`);if(!entryExists){// Create a new entry for this recurring payment\nnewEntries.push({id:uuidv4(),date:new Date(date),amount:payment.amount,description:`[Recurring] ${payment.description}`,type:payment.type});}});});// Add new entries if any were generated\nif(newEntries.length>0){setEntries(prevEntries=>[...prevEntries,...newEntries]);}};// Process recurring payments\nif(recurringPayments.length>0){processRecurringPayments();}},[recurringPayments,entries,currentDate]);// Calculate month data\nconst monthData=useMemo(()=>{const startDate=startOfMonth(currentDate);const endDate=endOfMonth(currentDate);const daysInMonth=eachDayOfInterval({start:startDate,end:endDate});const days=daysInMonth.reduce((acc,day)=>{const formattedDate=format(day,'yyyy-MM-dd');const dayEntries=entries.filter(entry=>isSameDay(entry.date,day));const totalIncome=dayEntries.filter(entry=>entry.type==='income').reduce((sum,entry)=>sum+entry.amount,0);const totalExpenses=dayEntries.filter(entry=>entry.type==='expense').reduce((sum,entry)=>sum+entry.amount,0);acc[formattedDate]={date:day,entries:dayEntries,totalIncome,totalExpenses,dailyBalance:totalIncome-totalExpenses,runningBalance:0// Calculated after all days are processed\n};return acc;},{});// Calculate running balance\nlet runningBalance=0;for(const day of daysInMonth){const formattedDate=format(day,'yyyy-MM-dd');runningBalance+=days[formattedDate].dailyBalance;days[formattedDate].runningBalance=runningBalance;}// Calculate total income, expenses, and balance for the month\nconst totalIncome=Object.values(days).reduce((sum,day)=>sum+day.totalIncome,0);const totalExpenses=Object.values(days).reduce((sum,day)=>sum+day.totalExpenses,0);return{days,totalIncome,totalExpenses,monthlyBalance:totalIncome-totalExpenses};},[currentDate,entries]);// Calculate year data\nconst yearData=useMemo(()=>{const year=currentDate.getFullYear();const months=Array.from({length:12},(_,i)=>i);const monthSummaries=months.map(month=>{const monthEntries=entries.filter(entry=>entry.date.getFullYear()===year&&entry.date.getMonth()===month);const totalIncome=monthEntries.filter(entry=>entry.type==='income').reduce((sum,entry)=>sum+entry.amount,0);const totalExpenses=monthEntries.filter(entry=>entry.type==='expense').reduce((sum,entry)=>sum+entry.amount,0);return{month,year,totalIncome,totalExpenses,monthlyBalance:totalIncome-totalExpenses};});const totalIncome=monthSummaries.reduce((sum,month)=>sum+month.totalIncome,0);const totalExpenses=monthSummaries.reduce((sum,month)=>sum+month.totalExpenses,0);return{year,months:monthSummaries,totalIncome,totalExpenses,yearlyBalance:totalIncome-totalExpenses};},[currentDate,entries]);// Add a new financial entry\nconst addEntry=entry=>{const newEntry={...entry,id:uuidv4()};setEntries(prevEntries=>[...prevEntries,newEntry]);};// Update an existing financial entry\nconst updateEntry=updatedEntry=>{setEntries(prevEntries=>prevEntries.map(entry=>entry.id===updatedEntry.id?updatedEntry:entry));};// Delete a financial entry\nconst deleteEntry=id=>{setEntries(prevEntries=>prevEntries.filter(entry=>entry.id!==id));};// Add a new recurring payment\nconst addRecurringPayment=payment=>{const newPayment={...payment,id:uuidv4()};// Immediately process this new payment to create entries\nconst today=new Date();today.setHours(0,0,0,0);// Selected month in the UI\nconst selectedMonthStart=startOfMonth(currentDate);const selectedMonthEnd=endOfMonth(currentDate);// The end date should be the later of today's month end or the selected month end\nconst endDate=new Date(Math.max(endOfMonth(today).getTime(),selectedMonthEnd.getTime()));let datesToProcess=[];if(newPayment.isActive){// Get the earlier of the selected month start or today (for processing)\nconst startDate=new Date(Math.min(today.getTime(),selectedMonthStart.getTime()));// Check if the payment schedule is valid \nconst processingStart=new Date(Math.max(newPayment.startDate.getTime(),startDate.getTime()));const processingEnd=newPayment.endDate&&isBefore(newPayment.endDate,endDate)?newPayment.endDate:endDate;if(!isAfter(processingStart,processingEnd)){// Get dates based on schedule type\nswitch(newPayment.scheduleType){case'specific-date':if(newPayment.frequency==='monthly'&&newPayment.dayOfMonth){const allDays=eachDayOfInterval({start:processingStart,end:processingEnd});datesToProcess=allDays.filter(date=>getDate(date)===newPayment.dayOfMonth);}else if(newPayment.frequency==='yearly'&&newPayment.dayOfMonth){const allDays=eachDayOfInterval({start:processingStart,end:processingEnd});datesToProcess=allDays.filter(date=>getDate(date)===newPayment.dayOfMonth&&date.getMonth()===newPayment.startDate.getMonth());}break;case'weekdays-only':datesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd}).filter(date=>!isWeekend(date));break;case'weekends-only':datesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd}).filter(date=>isWeekend(date));break;case'custom-range':datesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd});switch(newPayment.frequency){case'daily':break;case'weekly':datesToProcess=datesToProcess.filter(date=>date.getDay()===newPayment.startDate.getDay());break;case'monthly':datesToProcess=datesToProcess.filter(date=>getDate(date)===getDate(newPayment.startDate));break;case'yearly':datesToProcess=datesToProcess.filter(date=>getDate(date)===getDate(newPayment.startDate)&&date.getMonth()===newPayment.startDate.getMonth());break;}break;}// Create entries for dates\nconst newEntries=datesToProcess.map(date=>({id:uuidv4(),date:new Date(date),amount:newPayment.amount,description:`[Recurring] ${newPayment.description}`,type:newPayment.type}));if(newEntries.length>0){setEntries(prevEntries=>[...prevEntries,...newEntries]);}}}setRecurringPayments(prevPayments=>[...prevPayments,newPayment]);};// Update an existing recurring payment\nconst updateRecurringPayment=updatedPayment=>{// Get the existing payment to compare descriptions\nconst existingPayment=recurringPayments.find(p=>p.id===updatedPayment.id);if(!existingPayment)return;// First, remove all existing entries for this recurring payment\nsetEntries(prevEntries=>prevEntries.filter(entry=>!entry.description.startsWith(`[Recurring] ${existingPayment.description}`)));// Update the recurring payment\nsetRecurringPayments(prevPayments=>prevPayments.map(payment=>payment.id===updatedPayment.id?updatedPayment:payment));// If the payment is active, process it immediately to create new entries\nif(updatedPayment.isActive){const today=new Date();today.setHours(0,0,0,0);const selectedMonthStart=startOfMonth(currentDate);const selectedMonthEnd=endOfMonth(currentDate);const endDate=new Date(Math.max(endOfMonth(today).getTime(),selectedMonthEnd.getTime()));let datesToProcess=[];const startDate=new Date(Math.min(today.getTime(),selectedMonthStart.getTime()));const processingStart=new Date(Math.max(updatedPayment.startDate.getTime(),startDate.getTime()));const processingEnd=updatedPayment.endDate&&isBefore(updatedPayment.endDate,endDate)?updatedPayment.endDate:endDate;if(!isAfter(processingStart,processingEnd)){switch(updatedPayment.scheduleType){case'specific-date':if(updatedPayment.frequency==='monthly'&&updatedPayment.dayOfMonth){const allDays=eachDayOfInterval({start:processingStart,end:processingEnd});datesToProcess=allDays.filter(date=>getDate(date)===updatedPayment.dayOfMonth);}else if(updatedPayment.frequency==='yearly'&&updatedPayment.dayOfMonth){const allDays=eachDayOfInterval({start:processingStart,end:processingEnd});datesToProcess=allDays.filter(date=>getDate(date)===updatedPayment.dayOfMonth&&date.getMonth()===updatedPayment.startDate.getMonth());}break;case'weekdays-only':datesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd}).filter(date=>!isWeekend(date));break;case'weekends-only':datesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd}).filter(date=>isWeekend(date));break;case'custom-range':datesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd});switch(updatedPayment.frequency){case'daily':break;case'weekly':datesToProcess=datesToProcess.filter(date=>date.getDay()===updatedPayment.startDate.getDay());break;case'monthly':datesToProcess=datesToProcess.filter(date=>getDate(date)===getDate(updatedPayment.startDate));break;case'yearly':datesToProcess=datesToProcess.filter(date=>getDate(date)===getDate(updatedPayment.startDate)&&date.getMonth()===updatedPayment.startDate.getMonth());break;}break;}// Create new entries for the updated payment\nconst newEntries=datesToProcess.map(date=>({id:uuidv4(),date:new Date(date),amount:updatedPayment.amount,description:`[Recurring] ${updatedPayment.description}`,type:updatedPayment.type}));if(newEntries.length>0){setEntries(prevEntries=>[...prevEntries,...newEntries]);}}}};// Delete a recurring payment\nconst deleteRecurringPayment=id=>{// Get the payment before deleting it\nconst paymentToDelete=recurringPayments.find(payment=>payment.id===id);if(paymentToDelete){// Remove all entries associated with this recurring payment\nsetEntries(prevEntries=>{const updatedEntries=prevEntries.filter(entry=>!entry.description.startsWith(`[Recurring] ${paymentToDelete.description}`));return updatedEntries;});}// Remove the recurring payment\nsetRecurringPayments(prevPayments=>{const updatedPayments=prevPayments.filter(payment=>payment.id!==id);return updatedPayments;});};return{entries,addEntry,updateEntry,deleteEntry,recurringPayments,addRecurringPayment,updateRecurringPayment,deleteRecurringPayment,monthData,yearData};};","map":{"version":3,"names":["useState","useEffect","useMemo","useCallback","v4","uuidv4","format","startOfMonth","endOfMonth","eachDayOfInterval","isAfter","isBefore","isSameDay","isWeekend","getDate","useAuth","ENTRIES_STORAGE_KEY","RECURRING_PAYMENTS_STORAGE_KEY","dateReviver","key","value","Date","useFinancialData","currentDate","arguments","length","undefined","currentUser","entries","setEntries","recurringPayments","setRecurringPayments","getStorageKey","id","savedEntries","localStorage","getItem","parsedEntries","JSON","parse","map","entry","date","setItem","stringify","removeItem","savedRecurringPayments","parsedPayments","payment","startDate","endDate","validFrom","validUntil","processRecurringPayments","today","setHours","selectedMonthStart","selectedMonthEnd","pastProcessingDate","setDate","Math","min","getTime","max","newEntries","forEach","isActive","paymentEndDate","datesToProcess","processingStart","processingEnd","scheduleType","frequency","dayOfMonth","allDays","start","end","filter","getMonth","getDay","entryExists","some","description","push","amount","type","prevEntries","monthData","daysInMonth","days","reduce","acc","day","formattedDate","dayEntries","totalIncome","sum","totalExpenses","dailyBalance","runningBalance","Object","values","monthlyBalance","yearData","year","getFullYear","months","Array","from","_","i","monthSummaries","month","monthEntries","yearlyBalance","addEntry","newEntry","updateEntry","updatedEntry","deleteEntry","addRecurringPayment","newPayment","prevPayments","updateRecurringPayment","updatedPayment","existingPayment","find","p","startsWith","deleteRecurringPayment","paymentToDelete","updatedEntries","updatedPayments"],"sources":["C:/Users/Administrator/Downloads/personal-budget-tracker/src/hooks/useFinancialData.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback } from 'react';\nimport { \n  FinancialEntry, \n  RecurringPayment\n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  format, \n  startOfMonth, \n  endOfMonth, \n  eachDayOfInterval, \n  isAfter, \n  isBefore, \n  isSameDay, \n  isWeekend,\n  getDate\n} from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\n\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key: string, value: any) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\n\nexport const useFinancialData = (currentDate: Date = new Date()) => {\n  const { currentUser } = useAuth();\n  const [entries, setEntries] = useState<FinancialEntry[]>([]);\n  const [recurringPayments, setRecurringPayments] = useState<RecurringPayment[]>([]);\n\n  // Get storage key for the current user\n  const getStorageKey = useCallback((key: string) => {\n    return currentUser \n      ? `${key}-${currentUser.id}`\n      : key;\n  }, [currentUser]);\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map((entry: any) => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    } else {\n      // If there are no entries, remove the item from localStorage\n      localStorage.removeItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map((payment: any) => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    } else {\n      // If there are no recurring payments, remove the item from localStorage\n      localStorage.removeItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Current actual date (today)\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      // Selected month in the UI (might be different from current month)\n      const selectedMonthStart = startOfMonth(currentDate);\n      const selectedMonthEnd = endOfMonth(currentDate);\n      \n      // Consider a period of up to 30 days in the past from today (for historical data)\n      const pastProcessingDate = new Date(today);\n      pastProcessingDate.setDate(pastProcessingDate.getDate() - 30);\n      \n      // The start of processing should be the earlier of:\n      // 1. 30 days before today (for recent past entries)\n      // 2. The start of the selected month (for viewing past/future months)\n      const startDate = new Date(Math.min(pastProcessingDate.getTime(), selectedMonthStart.getTime()));\n      \n      // The end of processing should be the later of:\n      // 1. The end of the current actual month (for immediate visibility)\n      // 2. The end of the selected month (for viewing past/future months)\n      const endDate = new Date(\n        Math.max(\n          endOfMonth(today).getTime(),\n          selectedMonthEnd.getTime()\n        )\n      );\n      \n      // Prepare new entries generated from recurring payments\n      const newEntries: FinancialEntry[] = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is valid during any part of our processing window\n        const paymentEndDate = payment.validUntil || new Date(9999, 11, 31); // If no end date, use far future\n        \n        // If the payment's validity period doesn't overlap with our processing period, skip it\n        if (isAfter(payment.validFrom, endDate) || isBefore(paymentEndDate, startDate)) {\n          return;\n        }\n\n        // Get dates to process based on schedule type\n        let datesToProcess: Date[] = [];\n        \n        // Define start date for processing (max of payment's start date or our processing window start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), startDate.getTime()));\n        \n        // Define end date for processing (min of payment's end date or processing window end)\n        const processingEnd = payment.endDate && isBefore(payment.endDate, endDate) \n          ? payment.endDate \n          : endDate;\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              // Filter for days that match the day of month\n              datesToProcess = allDays.filter(date => getDate(date) === payment.dayOfMonth);\n            } \n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              // Filter for days that match both the month and day\n              datesToProcess = allDays.filter(date => \n                getDate(date) === payment.dayOfMonth &&\n                date.getMonth() === payment.startDate.getMonth()\n              );\n            }\n            break;\n            \n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n            \n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n            \n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n                \n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === payment.startDate.getDay()\n                );\n                break;\n                \n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate)\n                );\n                break;\n                \n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate) && \n                  date.getMonth() === payment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => \n            isSameDay(entry.date, date) && \n            entry.description === `[Recurring] ${payment.description}`\n          );\n\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries, currentDate]);\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({ start: startDate, end: endDate });\n\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      \n      const totalIncome = dayEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = dayEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0, // Calculated after all days are processed\n      };\n\n      return acc;\n    }, {} as Record<string, any>);\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalIncome,\n      0\n    );\n    const totalExpenses = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalExpenses,\n      0\n    );\n\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({ length: 12 }, (_, i) => i);\n\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => \n        entry.date.getFullYear() === year && \n        entry.date.getMonth() === month\n      );\n\n      const totalIncome = monthEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = monthEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses,\n      };\n    });\n\n    const totalIncome = monthSummaries.reduce(\n      (sum, month) => sum + month.totalIncome,\n      0\n    );\n    const totalExpenses = monthSummaries.reduce(\n      (sum, month) => sum + month.totalExpenses,\n      0\n    );\n\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = (entry: Omit<FinancialEntry, 'id'>) => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4(),\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = (updatedEntry: FinancialEntry) => {\n    setEntries(prevEntries =>\n      prevEntries.map(entry => \n        entry.id === updatedEntry.id ? updatedEntry : entry\n      )\n    );\n  };\n\n  // Delete a financial entry\n  const deleteEntry = (id: string) => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = (payment: Omit<RecurringPayment, 'id'>) => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4(),\n    };\n    \n    // Immediately process this new payment to create entries\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    // Selected month in the UI\n    const selectedMonthStart = startOfMonth(currentDate);\n    const selectedMonthEnd = endOfMonth(currentDate);\n    \n    // The end date should be the later of today's month end or the selected month end\n    const endDate = new Date(\n      Math.max(\n        endOfMonth(today).getTime(),\n        selectedMonthEnd.getTime()\n      )\n    );\n    \n    let datesToProcess: Date[] = [];\n    \n    if (newPayment.isActive) {\n      // Get the earlier of the selected month start or today (for processing)\n      const startDate = new Date(Math.min(today.getTime(), selectedMonthStart.getTime()));\n      \n      // Check if the payment schedule is valid \n      const processingStart = new Date(Math.max(newPayment.startDate.getTime(), startDate.getTime()));\n      const processingEnd = newPayment.endDate && isBefore(newPayment.endDate, endDate) \n        ? newPayment.endDate \n        : endDate;\n      \n      if (!isAfter(processingStart, processingEnd)) {\n        // Get dates based on schedule type\n        switch (newPayment.scheduleType) {\n          case 'specific-date':\n            if (newPayment.frequency === 'monthly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => getDate(date) === newPayment.dayOfMonth);\n            } else if (newPayment.frequency === 'yearly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => \n                getDate(date) === newPayment.dayOfMonth &&\n                date.getMonth() === newPayment.startDate.getMonth()\n              );\n            }\n            break;\n          case 'weekdays-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            switch (newPayment.frequency) {\n              case 'daily':\n                break;\n              case 'weekly':\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === newPayment.startDate.getDay()\n                );\n                break;\n              case 'monthly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(newPayment.startDate)\n                );\n                break;\n              case 'yearly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(newPayment.startDate) && \n                  date.getMonth() === newPayment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n        \n        // Create entries for dates\n        const newEntries: FinancialEntry[] = datesToProcess.map(date => ({\n          id: uuidv4(),\n          date: new Date(date),\n          amount: newPayment.amount,\n          description: `[Recurring] ${newPayment.description}`,\n          type: newPayment.type\n        }));\n        \n        if (newEntries.length > 0) {\n          setEntries(prevEntries => [...prevEntries, ...newEntries]);\n        }\n      }\n    }\n    \n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = (updatedPayment: RecurringPayment) => {\n    // Get the existing payment to compare descriptions\n    const existingPayment = recurringPayments.find(p => p.id === updatedPayment.id);\n    if (!existingPayment) return;\n\n    // First, remove all existing entries for this recurring payment\n    setEntries(prevEntries => \n      prevEntries.filter(entry => \n        !entry.description.startsWith(`[Recurring] ${existingPayment.description}`)\n      )\n    );\n\n    // Update the recurring payment\n    setRecurringPayments(prevPayments =>\n      prevPayments.map(payment =>\n        payment.id === updatedPayment.id ? updatedPayment : payment\n      )\n    );\n\n    // If the payment is active, process it immediately to create new entries\n    if (updatedPayment.isActive) {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      const selectedMonthStart = startOfMonth(currentDate);\n      const selectedMonthEnd = endOfMonth(currentDate);\n      \n      const endDate = new Date(\n        Math.max(\n          endOfMonth(today).getTime(),\n          selectedMonthEnd.getTime()\n        )\n      );\n      \n      let datesToProcess: Date[] = [];\n      const startDate = new Date(Math.min(today.getTime(), selectedMonthStart.getTime()));\n      \n      const processingStart = new Date(Math.max(updatedPayment.startDate.getTime(), startDate.getTime()));\n      const processingEnd = updatedPayment.endDate && isBefore(updatedPayment.endDate, endDate) \n        ? updatedPayment.endDate \n        : endDate;\n      \n      if (!isAfter(processingStart, processingEnd)) {\n        switch (updatedPayment.scheduleType) {\n          case 'specific-date':\n            if (updatedPayment.frequency === 'monthly' && updatedPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => getDate(date) === updatedPayment.dayOfMonth);\n            } else if (updatedPayment.frequency === 'yearly' && updatedPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => \n                getDate(date) === updatedPayment.dayOfMonth &&\n                date.getMonth() === updatedPayment.startDate.getMonth()\n              );\n            }\n            break;\n          case 'weekdays-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            switch (updatedPayment.frequency) {\n              case 'daily':\n                break;\n              case 'weekly':\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === updatedPayment.startDate.getDay()\n                );\n                break;\n              case 'monthly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(updatedPayment.startDate)\n                );\n                break;\n              case 'yearly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(updatedPayment.startDate) && \n                  date.getMonth() === updatedPayment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n        \n        // Create new entries for the updated payment\n        const newEntries: FinancialEntry[] = datesToProcess.map(date => ({\n          id: uuidv4(),\n          date: new Date(date),\n          amount: updatedPayment.amount,\n          description: `[Recurring] ${updatedPayment.description}`,\n          type: updatedPayment.type\n        }));\n        \n        if (newEntries.length > 0) {\n          setEntries(prevEntries => [...prevEntries, ...newEntries]);\n        }\n      }\n    }\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = (id: string) => {\n    // Get the payment before deleting it\n    const paymentToDelete = recurringPayments.find(payment => payment.id === id);\n    \n    if (paymentToDelete) {\n      // Remove all entries associated with this recurring payment\n      setEntries(prevEntries => {\n        const updatedEntries = prevEntries.filter(entry => \n          !entry.description.startsWith(`[Recurring] ${paymentToDelete.description}`)\n        );\n        return updatedEntries;\n      });\n    }\n    \n    // Remove the recurring payment\n    setRecurringPayments(prevPayments => {\n      const updatedPayments = prevPayments.filter(payment => payment.id !== id);\n      return updatedPayments;\n    });\n  };\n\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData,\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}